# UI Architecture Design

Personal dashboard for Stellaris game statistics with real-time updates and AI agent integration.

## Tech Stack

- **Frontend:** React 19 + Vite + TypeScript (strict) + vanilla-extract + uPlot
- **Real-time:** GraphQL subscriptions via Apollo Client + graphql-ws
- **Backend changes:** Add subscriptions to Apollo Server, Redis pub/sub for events
- **AI integration:** SSE streaming from Python agent with full event observability
- **Styling:** Stellaris-themed (Jura/Orbitron/Century Gothic fonts, dark space aesthetic)

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         FRONTEND (new)                              │
│  React + Vite + TypeScript + vanilla-extract + uPlot                │
│  Apollo Client with graphql-ws subscriptions                        │
└─────────────────────────────────────────────────────────────────────┘
                    │ GraphQL queries          │ WebSocket subscriptions
                    ▼                          ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    APOLLO SERVER (existing, extended)               │
│  + graphql-ws for subscriptions                                     │
│  + Redis pub/sub for event distribution                             │
└─────────────────────────────────────────────────────────────────────┘
        │                       │                        │
        ▼                       ▼                        ▼
   PostgreSQL              Redis Cache              Redis Pub/Sub
   (existing)              (existing)                  (new)
        ▲
        │
┌───────┴───────┐
│    PARSER     │ ─── publishes "gamestateCreated" event ──▶ Redis
│  (existing)   │
└───────────────┘
```

Parser publishes lightweight notifications to Redis pub/sub when it writes a new gamestate:

```json
{ "type": "gamestateCreated", "saveId": 123, "gamestateId": 456 }
```

Apollo Server subscribes to Redis, fetches full data from PostgreSQL, and pushes to connected clients via WebSocket.

## Frontend Structure

```
ui/
├── src/
│   ├── main.tsx
│   ├── App.tsx
│   ├── components/
│   │   ├── SaveList/
│   │   ├── TimeSeriesChart/
│   │   ├── BudgetDashboard/
│   │   └── AgentPanel/
│   ├── graphql/
│   │   ├── queries.ts
│   │   ├── subscriptions.ts
│   │   └── generated/
│   ├── hooks/
│   │   ├── useRealtimeBudget.ts
│   │   └── useAgentRun.ts
│   ├── styles/
│   │   ├── theme.css.ts
│   │   └── global.css.ts
│   └── lib/
│       └── apollo.ts
├── tests/
│   ├── components/
│   ├── hooks/
│   └── test-utils/
├── index.html
├── vite.config.ts
├── tsconfig.json
├── tsconfig.app.json
├── tsconfig.tests.json
└── package.json
```

### TypeScript Configuration

Extends root `tsconfig.common.json` for shared strict settings:

**ui/tsconfig.json:**
```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" }
  ]
}
```

**ui/tsconfig.app.json:**
```json
{
  "extends": "../tsconfig.common.json",
  "compilerOptions": {
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": [],
    "jsx": "react-jsx"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**ui/tsconfig.tests.json:**
```json
{
  "extends": "../tsconfig.common.json",
  "compilerOptions": {
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": ["bun"],
    "jsx": "react-jsx",
    "noEmit": true
  },
  "include": ["tests/**/*", "src/**/*"],
  "exclude": ["node_modules"]
}
```

## GraphQL Schema Changes

New subscription type in `graphql/schema.graphql`:

```graphql
type Subscription {
  gamestateCreated(saveId: Int!): Gamestate!
}
```

### Backend Changes

1. **New dependencies:**
   - `graphql-ws` - WebSocket server for subscriptions
   - `ws` - WebSocket implementation
   - `graphql-subscriptions` - PubSub implementation

2. **Apollo Server setup** (`src/graphql/graphqlServerMain.ts`):
   - Add WebSocket server alongside HTTP
   - Configure `graphql-ws` to handle subscription connections
   - Create Redis-backed PubSub instance

3. **New subscription resolver** (`src/graphql/resolvers/Subscription/gamestateCreated.ts`):
   ```typescript
   export const gamestateCreated: SubscriptionResolver = {
     subscribe: (_, { saveId }) => {
       return pubsub.asyncIterator(`gamestate:${saveId}`)
     },
     resolve: async (gamestateId: number) => {
       return getGamestateById(gamestateId)
     }
   }
   ```

4. **Parser publishes events** (`src/parser/parserMain.ts`):
   ```typescript
   await redis.publish(`gamestate:${saveId}`, JSON.stringify({ gamestateId }))
   ```

## AI Agent Integration

SSE-based streaming with full agent loop observability. Fire-and-forget initially, extensible to two-way interaction via SSE + POST hybrid.

```
Frontend                    Agent Runner (HTTP)              Python Agent
─────────────────────────────────────────────────────────────────────────
POST /api/agent/run ──────▶ spawn subprocess

     ◀─── SSE: {"event": "node:user_prompt", ...}
     ◀─── SSE: {"event": "node:model_request_start"}
     ◀─── SSE: {"event": "part:start", ...}
     ◀─── SSE: {"event": "part:delta:text", ...}
     ◀─── SSE: {"event": "tool:call", ...}
     ◀─── SSE: {"event": "tool:result", ...}
     ◀─── SSE: {"event": "node:end", ...}
```

### Python Agent Streaming

Uses pydantic-ai's `agent.iter()` with `node.stream()` for full event streaming:

```python
async def run_with_full_streaming(save_filename: str, output_stream):
    async with agent.iter(prompt, deps=deps) as run:
        async for node in run:
            if Agent.is_user_prompt_node(node):
                await output_stream.send({
                    "event": "node:user_prompt",
                    "prompt": node.user_prompt
                })
            elif Agent.is_model_request_node(node):
                await output_stream.send({"event": "node:model_request_start"})

                async with node.stream(run.ctx) as request_stream:
                    async for event in request_stream:
                        await output_stream.send(serialize_event(event))

                    async for text in request_stream.stream_text():
                        await output_stream.send({
                            "event": "stream:text",
                            "text": text
                        })

            elif Agent.is_call_tools_node(node):
                await output_stream.send({"event": "node:call_tools_start"})

                async with node.stream(run.ctx) as tool_stream:
                    async for event in tool_stream:
                        await output_stream.send(serialize_event(event))

            elif Agent.is_end_node(node):
                await output_stream.send({
                    "event": "node:end",
                    "result": run.result.output
                })
```

### Event Types

| Event | Description |
|-------|-------------|
| `node:user_prompt` | Agent received user input |
| `node:model_request_start` | Starting LLM request |
| `node:call_tools_start` | About to execute tools |
| `node:end` | Agent loop complete |
| `part:start` | New part (text/tool_call) beginning |
| `part:delta:text` | Text chunk |
| `part:delta:thinking` | Thinking/reasoning chunk |
| `part:delta:tool_args` | Tool arguments streaming |
| `tool:call` | Tool invoked with full args |
| `tool:result` | Tool returned result |
| `result:final` | Final structured result ready |
| `stream:text` | Accumulated text output |

Frontend can filter events by verbosity level (minimal/normal/verbose).

### Future Two-Way Interaction

SSE + POST hybrid approach:
- Keep SSE for agent output streaming
- Add POST endpoint for user replies
- Works for turn-based conversation without adding WebSocket complexity

## Data Flow & State Management

React state + Apollo Client cache. No Redux/Zustand unless complexity demands it.

### Custom Hook

```typescript
function useRealtimeBudget(saveId: number) {
  const { data: initial } = useQuery(GET_BUDGET, { variables: { saveId } })
  const [gamestates, setGamestates] = useState<Gamestate[]>([])

  useEffect(() => {
    if (initial) setGamestates(initial.save.gamestates)
  }, [initial])

  useSubscription(GAMESTATE_CREATED, {
    variables: { saveId },
    onData: ({ data }) => {
      setGamestates(prev => [...prev, data.gamestateCreated])
    }
  })

  return { gamestates, loading: !initial }
}
```

Local state for chart data (not Apollo cache) because:
- uPlot needs array format, not normalized cache
- Appending is simpler than cache merge policies
- Chart updates via `setData()` are more efficient than re-renders

## Theming & Styling

Stellaris game aesthetic with vanilla-extract.

### Fonts

```typescript
font: {
  menu: '"Jura", sans-serif',
  title: '"Orbitron", sans-serif',
  heading: '"Malgun Gothic", "Century Gothic", sans-serif',
  body: '"Century Gothic", "Segoe UI", sans-serif',
}
```

### Colors

```typescript
export const [themeClass, vars] = createTheme({
  color: {
    // Backgrounds
    void: '#05080a',
    background: '#0c1014',
    surface: 'rgba(20, 30, 40, 0.85)',
    surfaceHover: 'rgba(30, 45, 60, 0.9)',

    // Accents
    primary: '#00e696',
    primaryGlow: 'rgba(0, 230, 150, 0.3)',
    secondary: '#4a9eff',

    // Text
    text: '#e8e8e8',
    textMuted: '#8899aa',
    textBright: '#ffffff',

    // Borders
    border: 'rgba(70, 130, 180, 0.4)',
    borderBright: 'rgba(0, 230, 150, 0.6)',

    // Resources
    energy: '#f4c542',
    minerals: '#e63946',
    food: '#7cb518',
    alloys: '#c77dff',
    consumerGoods: '#ff922b',
    unity: '#22d3ee',
    influence: '#f97316',

    // Status
    success: '#00e696',
    warning: '#f4c542',
    error: '#e63946',
  },

  shadow: {
    panel: '0 0 20px rgba(0, 230, 150, 0.1), inset 0 0 60px rgba(0, 0, 0, 0.5)',
    glow: '0 0 10px currentColor',
  }
})
```

### Panel Styling

```typescript
export const panel = style({
  backgroundColor: vars.color.surface,
  border: `1px solid ${vars.color.border}`,
  boxShadow: vars.shadow.panel,
  backdropFilter: 'blur(8px)',
  borderRadius: vars.radius.sm,
})
```

## uPlot Chart Configuration

uPlot for performance with 12k+ data points (300 years × 4 saves/year × 10 series).

### React Wrapper

```typescript
interface TimeSeriesChartProps {
  data: {
    timestamps: number[]
    series: {
      key: string
      label: string
      values: number[]
      color: string
    }[]
  }
  title: string
  height?: number
}
```

### Configuration

```typescript
export const createChartOptions = (title: string, series: SeriesConfig[]): uPlot.Options => ({
  width: 0,
  height: 300,
  background: 'transparent',

  axes: [
    {
      stroke: vars.color.textMuted,
      grid: { stroke: 'rgba(70, 130, 180, 0.15)', width: 1 },
      ticks: { stroke: vars.color.border, width: 1 },
      font: `12px ${vars.font.body}`,
      values: (_, ticks) => ticks.map(formatGameDate),
    },
    {
      stroke: vars.color.textMuted,
      grid: { stroke: 'rgba(70, 130, 180, 0.15)', width: 1 },
      ticks: { stroke: vars.color.border, width: 1 },
      font: `12px ${vars.font.body}`,
    }
  ],

  series: [
    { label: 'Date' },
    ...series.map(s => ({
      label: s.label,
      stroke: s.color,
      width: 2,
      points: { show: false },
      focus: { alpha: 1 },
    }))
  ],

  cursor: {
    show: true,
    drag: { x: true, y: false },
    sync: { key: 'budget' },
  },

  legend: { show: true },
  scales: { x: { time: false } },
})
```

### Auto-Follow Latest Datapoint

Solves Grafana's future date issue:

```typescript
function useAutoFollow(chartRef: RefObject<uPlot>, enabled: boolean) {
  useEffect(() => {
    if (!enabled || !chartRef.current) return

    const chart = chartRef.current
    const data = chart.data[0]
    if (!data?.length) return

    const lastTimestamp = data[data.length - 1]
    const visibleRange = chart.scales.x.max - chart.scales.x.min

    chart.setScale('x', {
      min: lastTimestamp - visibleRange,
      max: lastTimestamp,
    })
  }, [chartRef.current?.data, enabled])
}
```

## Dependencies

### Frontend (`ui/package.json`)

```json
{
  "name": "stellaris-stats-ui",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "codegen": "graphql-codegen --config codegen.yml",
    "lint": "eslint .",
    "test": "bun test --watch",
    "test:ci": "bun test"
  },
  "dependencies": {
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "@apollo/client": "3.12.0",
    "graphql": "16.12.0",
    "graphql-ws": "5.16.0",
    "uplot": "1.6.31",
    "uplot-react": "1.2.2"
  },
  "devDependencies": {
    "@types/react": "19.0.0",
    "@types/react-dom": "19.0.0",
    "@vanilla-extract/css": "1.17.0",
    "@vanilla-extract/vite-plugin": "4.0.0",
    "@graphql-codegen/cli": "6.1.0",
    "@graphql-codegen/client-preset": "4.5.0",
    "@testing-library/react": "16.0.0",
    "@testing-library/user-event": "14.5.0",
    "happy-dom": "15.0.0",
    "typescript": "5.9.3",
    "vite": "6.0.0"
  }
}
```

### Backend Additions

```json
{
  "dependencies": {
    "graphql-ws": "5.16.0",
    "ws": "8.18.0",
    "graphql-subscriptions": "3.0.0"
  }
}
```

### Root `package.json` Scripts

```json
{
  "scripts": {
    "ui:dev": "cd ui && npm run dev",
    "ui:build": "cd ui && npm run build",
    "ui:codegen": "cd ui && npm run codegen",
    "ui:lint": "cd ui && npm run lint",
    "ui:test": "cd ui && npm run test",
    "ui:test:ci": "cd ui && npm run test:ci"
  }
}
```

## Testing Strategy

Bun test runner with Testing Library, matching backend approach.

### Test Structure

```
ui/tests/
├── components/
│   ├── SaveList.test.tsx
│   ├── TimeSeriesChart.test.tsx
│   └── AgentPanel.test.tsx
├── hooks/
│   ├── useRealtimeBudget.test.ts
│   └── useAgentRun.test.ts
└── test-utils/
    ├── mockApolloProvider.tsx
    └── fixtures.ts
```

### What to Test

| Layer | What | How |
|-------|------|-----|
| Hooks | `useRealtimeBudget`, `useAgentRun` | Mock Apollo, verify state transitions |
| Components | Rendering, interactions | Testing Library, mock data |
| Data transforms | `transformToUPlotData`, `formatGameDate` | Unit tests, pure functions |
| Agent event parsing | SSE event to UI state | Unit tests with fixture events |

## CI Updates

Add to `.github/workflows/ci.yml`:

```yaml
  lint-ui:
    name: Lint UI
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6
        with:
          node-version: '24.12.0'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci && cd ui && npm ci
      - name: Run ESLint
        run: npm run ui:lint

  build-ui:
    name: Build UI
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6
        with:
          node-version: '24.12.0'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci && cd ui && npm ci
      - name: Build UI
        run: npm run ui:build

  test-ui:
    name: Test UI
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6
        with:
          node-version: '24.12.0'
          cache: 'npm'
      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.3.5'
      - name: Install dependencies
        run: npm ci && cd ui && npm ci
      - name: Run tests
        run: npm run ui:test:ci

  verify-codegen-ui:
    name: Verify UI Codegen
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6
        with:
          node-version: '24.12.0'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci && cd ui && npm ci
      - name: Run GraphQL codegen
        run: npm run ui:codegen
      - name: Check for uncommitted changes
        run: git diff --exit-code ui/src/graphql/generated/
```

## CLAUDE.md Updates

Add to Project Structure:
```
ui/                     # React frontend
  src/                  # UI source code
  tests/                # UI tests
```

Add UI commands table:
```markdown
### UI

| Task              | Command              |
| ----------------- | -------------------- |
| Dev server        | `npm run ui:dev`     |
| Build             | `npm run ui:build`   |
| GraphQL codegen   | `npm run ui:codegen` |
| Lint              | `npm run ui:lint`    |
| Test (watch)      | `npm run ui:test`    |
| Test (CI)         | `npm run ui:test:ci` |
```

Add to Quality Checks:
```markdown
After UI changes: `npm run ui:lint && npm run ui:build && npm run ui:test:ci`
```

## Files to Create/Modify

### New Files
- `ui/` - Entire frontend application directory
- `src/graphql/resolvers/Subscription/` - Subscription resolvers
- `docs/plans/2026-01-09-ui-design.md` - This document

### Modified Files
- `graphql/schema.graphql` - Add Subscription type
- `src/graphql/graphqlServerMain.ts` - Add WebSocket server
- `src/parser/parserMain.ts` - Add Redis publish on new gamestate
- `package.json` - Add UI scripts and backend dependencies
- `.github/workflows/ci.yml` - Add UI jobs
- `CLAUDE.md` - Add UI commands section
